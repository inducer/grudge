============================= test session starts ==============================
platform linux -- Python 3.7.1, pytest-4.2.1, py-1.7.0, pluggy-0.8.1
rootdir: /home/njchris2/Workspace/grudge, inifile:
collected 99 items

test_grudge.py ..................ssss..s..s.FFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 57%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFsssFFF                               [100%]

=================================== FAILURES ===================================
 test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect3-mesh_pars2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c748>
mesh_name = 'rect3', mesh_pars = [4, 6], op_type = 'strong'
flux_type = 'upwind', order = 4, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-weak-disk-mesh_pars0] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c748>
mesh_name = 'disk', mesh_pars = [0.1, 0.05], op_type = 'weak'
flux_type = 'upwind', order = 4, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-weak-rect2-mesh_pars1] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c748>
mesh_name = 'rect2', mesh_pars = [4, 8], op_type = 'weak', flux_type = 'upwind'
order = 4, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-weak-rect3-mesh_pars2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c748>
mesh_name = 'rect3', mesh_pars = [4, 6], op_type = 'weak', flux_type = 'upwind'
order = 4, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-5-upwind-strong-disk-mesh_pars0] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c748>
mesh_name = 'disk', mesh_pars = [0.1, 0.05], op_type = 'strong'
flux_type = 'upwind', order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-5-upwind-strong-rect2-mesh_pars1] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c748>
mesh_name = 'rect2', mesh_pars = [4, 8], op_type = 'strong'
flux_type = 'upwind', order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-5-upwind-strong-rect3-mesh_pars2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c748>
mesh_name = 'rect3', mesh_pars = [4, 6], op_type = 'strong'
flux_type = 'upwind', order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-5-upwind-weak-disk-mesh_pars0] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c748>
mesh_name = 'disk', mesh_pars = [0.1, 0.05], op_type = 'weak'
flux_type = 'upwind', order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-5-upwind-weak-rect2-mesh_pars1] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c748>
mesh_name = 'rect2', mesh_pars = [4, 8], op_type = 'weak', flux_type = 'upwind'
order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-5-upwind-weak-rect3-mesh_pars2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c748>
mesh_name = 'rect3', mesh_pars = [4, 6], op_type = 'weak', flux_type = 'upwind'
order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3-upwind-strong-disk-mesh_pars0] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'disk', mesh_pars = [0.1, 0.05], op_type = 'strong'
flux_type = 'upwind', order = 3, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3-upwind-strong-rect2-mesh_pars1] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'rect2', mesh_pars = [4, 8], op_type = 'strong'
flux_type = 'upwind', order = 3, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3-upwind-strong-rect3-mesh_pars2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'rect3', mesh_pars = [4, 6], op_type = 'strong'
flux_type = 'upwind', order = 3, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3-upwind-weak-disk-mesh_pars0] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'disk', mesh_pars = [0.1, 0.05], op_type = 'weak'
flux_type = 'upwind', order = 3, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3-upwind-weak-rect2-mesh_pars1] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'rect2', mesh_pars = [4, 8], op_type = 'weak', flux_type = 'upwind'
order = 3, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3-upwind-weak-rect3-mesh_pars2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'rect3', mesh_pars = [4, 6], op_type = 'weak', flux_type = 'upwind'
order = 3, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-4-upwind-strong-disk-mesh_pars0] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'disk', mesh_pars = [0.1, 0.05], op_type = 'strong'
flux_type = 'upwind', order = 4, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-4-upwind-strong-rect2-mesh_pars1] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'rect2', mesh_pars = [4, 8], op_type = 'strong'
flux_type = 'upwind', order = 4, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-4-upwind-strong-rect3-mesh_pars2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'rect3', mesh_pars = [4, 6], op_type = 'strong'
flux_type = 'upwind', order = 4, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-4-upwind-weak-disk-mesh_pars0] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'disk', mesh_pars = [0.1, 0.05], op_type = 'weak'
flux_type = 'upwind', order = 4, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-4-upwind-weak-rect2-mesh_pars1] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'rect2', mesh_pars = [4, 8], op_type = 'weak', flux_type = 'upwind'
order = 4, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-4-upwind-weak-rect3-mesh_pars2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'rect3', mesh_pars = [4, 6], op_type = 'weak', flux_type = 'upwind'
order = 4, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-5-upwind-strong-disk-mesh_pars0] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'disk', mesh_pars = [0.1, 0.05], op_type = 'strong'
flux_type = 'upwind', order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-5-upwind-strong-rect2-mesh_pars1] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'rect2', mesh_pars = [4, 8], op_type = 'strong'
flux_type = 'upwind', order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-5-upwind-strong-rect3-mesh_pars2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'rect3', mesh_pars = [4, 6], op_type = 'strong'
flux_type = 'upwind', order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-5-upwind-weak-disk-mesh_pars0] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'disk', mesh_pars = [0.1, 0.05], op_type = 'weak'
flux_type = 'upwind', order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-5-upwind-weak-rect2-mesh_pars1] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'rect2', mesh_pars = [4, 8], op_type = 'weak', flux_type = 'upwind'
order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-5-upwind-weak-rect3-mesh_pars2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c710>
mesh_name = 'rect3', mesh_pars = [4, 6], op_type = 'weak', flux_type = 'upwind'
order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3-upwind-strong-disk-mesh_pars0] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'disk', mesh_pars = [0.1, 0.05], op_type = 'strong'
flux_type = 'upwind', order = 3, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3-upwind-strong-rect2-mesh_pars1] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'rect2', mesh_pars = [4, 8], op_type = 'strong'
flux_type = 'upwind', order = 3, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3-upwind-strong-rect3-mesh_pars2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'rect3', mesh_pars = [4, 6], op_type = 'strong'
flux_type = 'upwind', order = 3, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3-upwind-weak-disk-mesh_pars0] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'disk', mesh_pars = [0.1, 0.05], op_type = 'weak'
flux_type = 'upwind', order = 3, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3-upwind-weak-rect2-mesh_pars1] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'rect2', mesh_pars = [4, 8], op_type = 'weak', flux_type = 'upwind'
order = 3, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3-upwind-weak-rect3-mesh_pars2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'rect3', mesh_pars = [4, 6], op_type = 'weak', flux_type = 'upwind'
order = 3, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-4-upwind-strong-disk-mesh_pars0] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'disk', mesh_pars = [0.1, 0.05], op_type = 'strong'
flux_type = 'upwind', order = 4, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-4-upwind-strong-rect2-mesh_pars1] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'rect2', mesh_pars = [4, 8], op_type = 'strong'
flux_type = 'upwind', order = 4, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-4-upwind-strong-rect3-mesh_pars2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'rect3', mesh_pars = [4, 6], op_type = 'strong'
flux_type = 'upwind', order = 4, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-4-upwind-weak-disk-mesh_pars0] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'disk', mesh_pars = [0.1, 0.05], op_type = 'weak'
flux_type = 'upwind', order = 4, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-4-upwind-weak-rect2-mesh_pars1] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'rect2', mesh_pars = [4, 8], op_type = 'weak', flux_type = 'upwind'
order = 4, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-4-upwind-weak-rect3-mesh_pars2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'rect3', mesh_pars = [4, 6], op_type = 'weak', flux_type = 'upwind'
order = 4, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-5-upwind-strong-disk-mesh_pars0] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'disk', mesh_pars = [0.1, 0.05], op_type = 'strong'
flux_type = 'upwind', order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-5-upwind-strong-rect2-mesh_pars1] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'rect2', mesh_pars = [4, 8], op_type = 'strong'
flux_type = 'upwind', order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-5-upwind-strong-rect3-mesh_pars2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'rect3', mesh_pars = [4, 6], op_type = 'strong'
flux_type = 'upwind', order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-5-upwind-weak-disk-mesh_pars0] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'disk', mesh_pars = [0.1, 0.05], op_type = 'weak'
flux_type = 'upwind', order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-5-upwind-weak-rect2-mesh_pars1] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'rect2', mesh_pars = [4, 8], op_type = 'weak', flux_type = 'upwind'
order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_advec[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-5-upwind-weak-rect3-mesh_pars2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1020c780>
mesh_name = 'rect3', mesh_pars = [4, 6], op_type = 'weak', flux_type = 'upwind'
order = 5, visualize = False

    @pytest.mark.parametrize(("mesh_name", "mesh_pars"), [
        ("disk", [0.1, 0.05]),
        ("rect2", [4, 8]),
        ("rect3", [4, 6]),
        ])
    @pytest.mark.parametrize("op_type", ["strong", "weak"])
    @pytest.mark.parametrize("flux_type", ["upwind"])
    @pytest.mark.parametrize("order", [3, 4, 5])
    # test: 'test_convergence_advec(cl._csc, "disk", [0.1, 0.05], "strong", "upwind", 3)'
    def test_convergence_advec(ctx_factory, mesh_name, mesh_pars, op_type, flux_type,
            order, visualize=False):
        """Test whether 2D advection actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_maxwell[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8f3fd0>
order = 3

    @pytest.mark.parametrize("order", [3, 4, 5])
    def test_convergence_maxwell(ctx_factory,  order):
        """Test whether 3D maxwells actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_maxwell[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8f3fd0>
order = 4

    @pytest.mark.parametrize("order", [3, 4, 5])
    def test_convergence_maxwell(ctx_factory,  order):
        """Test whether 3D maxwells actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_maxwell[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-5] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8f3fd0>
order = 5

    @pytest.mark.parametrize("order", [3, 4, 5])
    def test_convergence_maxwell(ctx_factory,  order):
        """Test whether 3D maxwells actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_maxwell[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8f3f98>
order = 3

    @pytest.mark.parametrize("order", [3, 4, 5])
    def test_convergence_maxwell(ctx_factory,  order):
        """Test whether 3D maxwells actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_maxwell[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-4] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8f3f98>
order = 4

    @pytest.mark.parametrize("order", [3, 4, 5])
    def test_convergence_maxwell(ctx_factory,  order):
        """Test whether 3D maxwells actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_maxwell[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-5] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8f3f98>
order = 5

    @pytest.mark.parametrize("order", [3, 4, 5])
    def test_convergence_maxwell(ctx_factory,  order):
        """Test whether 3D maxwells actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_maxwell[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8f3f60>
order = 3

    @pytest.mark.parametrize("order", [3, 4, 5])
    def test_convergence_maxwell(ctx_factory,  order):
        """Test whether 3D maxwells actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_maxwell[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-4] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8f3f60>
order = 4

    @pytest.mark.parametrize("order", [3, 4, 5])
    def test_convergence_maxwell(ctx_factory,  order):
        """Test whether 3D maxwells actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_convergence_maxwell[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-5] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8f3f60>
order = 5

    @pytest.mark.parametrize("order", [3, 4, 5])
    def test_convergence_maxwell(ctx_factory,  order):
        """Test whether 3D maxwells actually converges"""
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_improvement_quadrature[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8f3470>
order = 2

    @pytest.mark.parametrize("order", [2, 3, 4])
    def test_improvement_quadrature(ctx_factory, order):
        """Test whether quadrature improves things and converges"""
        from meshmode.mesh.generation import generate_regular_rect_mesh
        from grudge.models.advection import VariableCoefficientAdvectionOperator
        from pytools.convergence import EOCRecorder
        from pytools.obj_array import join_fields
        from meshmode.discretization.poly_element import QuadratureSimplexGroupFactory
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:414: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_improvement_quadrature[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8f3470>
order = 3

    @pytest.mark.parametrize("order", [2, 3, 4])
    def test_improvement_quadrature(ctx_factory, order):
        """Test whether quadrature improves things and converges"""
        from meshmode.mesh.generation import generate_regular_rect_mesh
        from grudge.models.advection import VariableCoefficientAdvectionOperator
        from pytools.convergence import EOCRecorder
        from pytools.obj_array import join_fields
        from meshmode.discretization.poly_element import QuadratureSimplexGroupFactory
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:414: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_improvement_quadrature[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8f3470>
order = 4

    @pytest.mark.parametrize("order", [2, 3, 4])
    def test_improvement_quadrature(ctx_factory, order):
        """Test whether quadrature improves things and converges"""
        from meshmode.mesh.generation import generate_regular_rect_mesh
        from grudge.models.advection import VariableCoefficientAdvectionOperator
        from pytools.convergence import EOCRecorder
        from pytools.obj_array import join_fields
        from meshmode.discretization.poly_element import QuadratureSimplexGroupFactory
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:414: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_improvement_quadrature[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8e5518>
order = 2

    @pytest.mark.parametrize("order", [2, 3, 4])
    def test_improvement_quadrature(ctx_factory, order):
        """Test whether quadrature improves things and converges"""
        from meshmode.mesh.generation import generate_regular_rect_mesh
        from grudge.models.advection import VariableCoefficientAdvectionOperator
        from pytools.convergence import EOCRecorder
        from pytools.obj_array import join_fields
        from meshmode.discretization.poly_element import QuadratureSimplexGroupFactory
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:414: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_improvement_quadrature[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8e5518>
order = 3

    @pytest.mark.parametrize("order", [2, 3, 4])
    def test_improvement_quadrature(ctx_factory, order):
        """Test whether quadrature improves things and converges"""
        from meshmode.mesh.generation import generate_regular_rect_mesh
        from grudge.models.advection import VariableCoefficientAdvectionOperator
        from pytools.convergence import EOCRecorder
        from pytools.obj_array import join_fields
        from meshmode.discretization.poly_element import QuadratureSimplexGroupFactory
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:414: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_improvement_quadrature[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-4] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8e5518>
order = 4

    @pytest.mark.parametrize("order", [2, 3, 4])
    def test_improvement_quadrature(ctx_factory, order):
        """Test whether quadrature improves things and converges"""
        from meshmode.mesh.generation import generate_regular_rect_mesh
        from grudge.models.advection import VariableCoefficientAdvectionOperator
        from pytools.convergence import EOCRecorder
        from pytools.obj_array import join_fields
        from meshmode.discretization.poly_element import QuadratureSimplexGroupFactory
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:414: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_improvement_quadrature[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8e58d0>
order = 2

    @pytest.mark.parametrize("order", [2, 3, 4])
    def test_improvement_quadrature(ctx_factory, order):
        """Test whether quadrature improves things and converges"""
        from meshmode.mesh.generation import generate_regular_rect_mesh
        from grudge.models.advection import VariableCoefficientAdvectionOperator
        from pytools.convergence import EOCRecorder
        from pytools.obj_array import join_fields
        from meshmode.discretization.poly_element import QuadratureSimplexGroupFactory
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:414: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_improvement_quadrature[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8e58d0>
order = 3

    @pytest.mark.parametrize("order", [2, 3, 4])
    def test_improvement_quadrature(ctx_factory, order):
        """Test whether quadrature improves things and converges"""
        from meshmode.mesh.generation import generate_regular_rect_mesh
        from grudge.models.advection import VariableCoefficientAdvectionOperator
        from pytools.convergence import EOCRecorder
        from pytools.obj_array import join_fields
        from meshmode.discretization.poly_element import QuadratureSimplexGroupFactory
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:414: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_improvement_quadrature[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-4] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c1e8e58d0>
order = 4

    @pytest.mark.parametrize("order", [2, 3, 4])
    def test_improvement_quadrature(ctx_factory, order):
        """Test whether quadrature improves things and converges"""
        from meshmode.mesh.generation import generate_regular_rect_mesh
        from grudge.models.advection import VariableCoefficientAdvectionOperator
        from pytools.convergence import EOCRecorder
        from pytools.obj_array import join_fields
        from meshmode.discretization.poly_element import QuadratureSimplexGroupFactory
    
>       cl_ctx = cl.create_some_context()

test_grudge.py:414: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_bessel[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c10237ba8>

    def test_bessel(ctx_factory):
>       cl_ctx = cl.create_some_context()

test_grudge.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_bessel[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c10237b70>

    def test_bessel(ctx_factory):
>       cl_ctx = cl.create_some_context()

test_grudge.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
 test_bessel[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>] 

ctx_factory = <pyopencl.tools.pytest_generate_tests_for_pyopencl.<locals>.ContextFactory object at 0x7f4c10237be0>

    def test_bessel(ctx_factory):
>       cl_ctx = cl.create_some_context()

test_grudge.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interactive = False, answers = None

    def create_some_context(interactive=None, answers=None):
        import os
        if answers is None:
            if "PYOPENCL_CTX" in os.environ:
                ctx_spec = os.environ["PYOPENCL_CTX"]
                answers = ctx_spec.split(":")
    
            if "PYOPENCL_TEST" in os.environ:
                from pyopencl.tools import get_test_platforms_and_devices
                for plat, devs in get_test_platforms_and_devices():
                    for dev in devs:
                        return Context([dev])
    
        if answers is not None:
            pre_provided_answers = answers
            answers = answers[:]
        else:
            pre_provided_answers = None
    
        user_inputs = []
    
        if interactive is None:
            interactive = True
            try:
                import sys
                if not sys.stdin.isatty():
                    interactive = False
            except Exception:
                interactive = False
    
        def cc_print(s):
            if interactive:
                print(s)
    
        def get_input(prompt):
            if answers:
                return str(answers.pop(0))
            elif not interactive:
                return ''
            else:
                user_input = input(prompt)
                user_inputs.append(user_input)
                return user_input
    
        # {{{ pick a platform
    
        platforms = get_platforms()
    
        if not platforms:
            raise Error("no platforms found")
        else:
            if not answers:
                cc_print("Choose platform:")
                for i, pf in enumerate(platforms):
                    cc_print("[%d] %s" % (i, pf))
    
            answer = get_input("Choice [0]:")
            if not answer:
                platform = platforms[0]
            else:
                platform = None
                try:
                    int_choice = int(answer)
                except ValueError:
                    pass
                else:
                    if 0 <= int_choice < len(platforms):
                        platform = platforms[int_choice]
    
                if platform is None:
                    answer = answer.lower()
                    for i, pf in enumerate(platforms):
                        if answer in pf.name.lower():
                            platform = pf
                    if platform is None:
                        raise RuntimeError("input did not match any platform")
    
        # }}}
    
        # {{{ pick a device
    
        devices = platform.get_devices()
    
        def parse_device(choice):
            try:
                int_choice = int(choice)
            except ValueError:
                pass
            else:
                if 0 <= int_choice < len(devices):
                    return devices[int_choice]
    
            choice = choice.lower()
            for i, dev in enumerate(devices):
                if choice in dev.name.lower():
                    return dev
            raise RuntimeError("input did not match any device")
    
        if not devices:
            raise Error("no devices found")
        elif len(devices) == 1:
            pass
        else:
            if not answers:
                cc_print("Choose device(s):")
                for i, dev in enumerate(devices):
                    cc_print("[%d] %s" % (i, dev))
    
            answer = get_input("Choice, comma-separated [0]:")
            if not answer:
                devices = [devices[0]]
            else:
                devices = [parse_device(i) for i in answer.split(",")]
    
        # }}}
    
        if user_inputs:
            if pre_provided_answers is not None:
                user_inputs = pre_provided_answers + user_inputs
            cc_print("Set the environment variable PYOPENCL_CTX='%s' to "
                    "avoid being asked again." % ":".join(user_inputs))
    
        if answers:
            raise RuntimeError("not all provided choices were used by "
                    "create_some_context. (left over: '%s')" % ":".join(answers))
    
>       return Context(devices)
E       pyopencl._cl.RuntimeError: Context failed: OUT_OF_HOST_MEMORY

../../../miniconda3/envs/dgfem/lib/python3.7/site-packages/pyopencl/__init__.py:1462: RuntimeError
=============================== warnings summary ===============================
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_1d_mass_mat_trig[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>]
test/test_grudge.py::test_1d_mass_mat_trig[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>]
test/test_grudge.py::test_1d_mass_mat_trig[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>]
test/test_grudge.py::test_1d_mass_mat_trig[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>]
test/test_grudge.py::test_1d_mass_mat_trig[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>]
test/test_grudge.py::test_1d_mass_mat_trig[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>]
test/test_grudge.py::test_1d_mass_mat_trig[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>]
test/test_grudge.py::test_1d_mass_mat_trig[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>]
test/test_grudge.py::test_1d_mass_mat_trig[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>]
test/test_grudge.py::test_1d_mass_mat_trig[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>]
test/test_grudge.py::test_1d_mass_mat_trig[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>]
test/test_grudge.py::test_1d_mass_mat_trig[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>]
test/test_grudge.py::test_1d_mass_mat_trig[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>]
test/test_grudge.py::test_1d_mass_mat_trig[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>]
test/test_grudge.py::test_1d_mass_mat_trig[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'pthread-Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Portable Computing Language'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-1]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-2]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_tri_diff_mat[<context factory for <pyopencl.Device 'Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz' on 'Intel(R) OpenCL'>-3]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
  /home/njchris2/miniconda3/envs/dgfem/lib/python3.7/site-packages/grudge/symbolic/compiler.py:998: DeprecationWarning: temp_var_type should be Optional() if no temporary, not None. This usage will be disallowed soon.
    ("*", "any"),

test/test_grudge.py::test_inverse_metric[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-2]
  /home/njchris2/miniconda3/envs/dgfem/lib/python3.7/site-packages/loopy/transform/iname.py:678: DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated, and in 3.8 it will stop working
    from collections import Iterable

test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-strong-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-3-upwind-weak-rect3-mesh_pars2]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
test/test_grudge.py::test_convergence_advec[<context factory for <pyopencl.Device 'TITAN V' on 'NVIDIA CUDA'>-4-upwind-strong-rect2-mesh_pars1]
  /home/njchris2/miniconda3/envs/dgfem/lib/python3.7/site-packages/grudge/symbolic/compiler.py:998: DeprecationWarning: temp_var_type should be Optional(None) if unspecified, not auto. This usage will be disallowed soon.
    ("*", "any"),

-- Docs: https://docs.pytest.org/en/latest/warnings.html
======= 67 failed, 23 passed, 9 skipped, 321 warnings in 132.64 seconds ========
